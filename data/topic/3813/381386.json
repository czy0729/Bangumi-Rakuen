{"id":381386,"avatar":"//lain.bgm.tv/pic/user/m/000/47/07/470741.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"作为一名十分业余的debugger，如果您能阅读这篇文章，我会非常开心。<br><br>我正在分析一份32位crackme，目标是找到钉在其exe文件中的单一的密码。这份crackme没有进行pack或是任何加工。Source Code应为C++，使用Visual Studio 2017进行compile。<br>这份crackme没有任何GUI，完全于command prompt内执行，其运作顺序也十分简单。唯一需要着眼观察的是其针对user input和sticked-in password的encode与decode。我正是于这一步骤停滞不前。在其用于encode的函数中，有大量为难读化而生的machine code，encode的算法也较为复杂。例如，其将类似于strcmp的指令变为比较一系列函数进行encode后与sticked-in password进行一种未知的比较后产生的bool值，然后利用此值判断password是否正确。<br>如果您有任何建议或头绪，还请发布于回复中。如若可能需要更详细的信息，请发布于回复中。<br><br>其exe程序，assembly文件与decompile的c code。<br><a href=\"https://icedrive.net/s/hBx9QtW77xNzWDbf2hTzf2AZC7S4\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">https://icedrive.net/s/hBx9QtW77xNzWDbf2hTzf2AZC7S4</a> ","time":"2023-5-6 07:12","title":"针对Crackme进行Reverse Engineering","userId":"xmydl","userName":"石原英里華(常盤るる)","userSign":""}