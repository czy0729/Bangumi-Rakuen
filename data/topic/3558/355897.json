{"avatar":"//lain.bgm.tv/pic/user/m/000/00/10/1010.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"想要做到的：<br><br>要做的：先提交N个任务给ThreadPoolExecutor，在任务里经过一段时间后又可能提交新的任务给ThreadPoolExecutor<br>需求：<br>1. 保证主线程不死、ThreadPoolExecutor不被shutdown可以继续接受子线程添加的任务<br>2. 保证每个任务返回后能及时返回，而不是在那里等待孙任务完成（这样会占用线程池，而且输出结果顺序会颠倒）<br><br>我试图用concurrent.futures自带的as_completed()，或者wait()，context manager等等，发现无法同时解决上述所有问题<br>唯一好使的是手动写个block循环遍历futures：<br><br><div class=\"codeHighlight\"><pre>from concurrent.futures import ThreadPoolExecutor<br>import time<br><br>def grandson():<br>    # time.sleep(2)<br>    return 456<br>def son():    <br>    # time.sleep(1)<br>    fs.append(executor.submit(grandson))<br>    time.sleep(3)<br>    return 123<br><br>fs = []<br>executor = ThreadPoolExecutor(max_workers=2)<br>fs.append(executor.submit(son))<br><br>while True:<br>    i = 0<br>    for f in fs:<br>        if f.done():<br>            if f.result():<br>                print(f.result()) # so it doesn't print None<br>            fs.remove(f)<br>    if len(fs) == 0:<br>        break<br>print('done')</pre></div><br><br>可以实现顺序输出：<br>456<br>123<br>done<br><br>（假设必须要用处理return的值的方式，不要在子线程里直接处理）<br><br>但是感觉不够优雅，有啥更好的写法么？ ","time":"2020-4-16 17:02","title":"[Python] ThreadPoolExecutor延时接受新job？","userId":"fireattack","userName":"烈之斩","userSign":"(V1046-R MAHORO)"}