{"avatar":"//lain.bgm.tv/pic/user/m/000/00/10/1010.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"from concurrent.futures import ThreadPoolExecutor<br>import time<br><br>def wait_on_future():<br>    f = executor.submit(pow, 5, 2)<br>    print(f.result())<br><br>executor = ThreadPoolExecutor(max_workers=2)<br>executor.submit(wait_on_future)<br><br>以上修改自<a href=\"https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">官方范例（反例）</a>，仅仅是把worker数量提升到了2（1会deadlock），正常工作<br><br>但是我测试过程中发现一个别的问题：<br>如果f并不是即时提交而是过了的一段时间（这里用了sleep不过随便换成别的长时间的操作都可以），就不能正常工作了：<br><br>from concurrent.futures import ThreadPoolExecutor<br>import time<br><br>def wait_on_future():<br>    time.sleep(1)<br>    f = executor.submit(pow, 5, 2)<br>    print(f.result())<br><br>executor = ThreadPoolExecutor(max_workers=2)<br>executor.submit(wait_on_future)<br><br>并没有print 10<br><br>事实上，如果你在下面加别的，会发现下面的任何代码都不会被执行的样子<br><br>from concurrent.futures import ThreadPoolExecutor<br>import time<br><br>def wait_on_future():<br>    time.sleep(1)<br>    f = executor.submit(pow, 5, 2)<br>    print(f.result())<br>    print('this should always print')<br><br>executor = ThreadPoolExecutor(max_workers=2)<br>executor.submit(wait_on_future)<br><br>现在不但10不print，连'this should always print'也不print了<br><br>--------------------<br>虽然知道ThreadPoolExecutor不用就会被回收，但是在提交f的时候明明wait_on_future这个child thread还在跑才对？<br><br>我试图改写成用wait()，context manager，shutdown(wait=True)，as_completed()，都无法解决问题。<br>唯一好使的是手动写个循环遍历futures：<br><br>from concurrent.futures import ThreadPoolExecutor<br>import time<br><br>def wait_on_future():<br>    time.sleep(1)<br>    fs.append(executor.submit(pow, 5, 2))<br>    print('this should always print')<br><br>fs = []<br>executor = ThreadPoolExecutor(max_workers=2)<br>fs.append(executor.submit(wait_on_future))<br><br>while True:<br>    a = 0<br>    for f in fs:<br>        if f.running():<br>            a += 1<br>        else:<br>            if f.result():<br>                print(f.result())<br>            fs.remove(f)<br>    if a == 0: <br>        break<br><br>但是感觉真的好蠢，ThreadPoolExecutor没有什么内置的方法能保证一直接受新任务么？ ","time":"2020-4-16 17:02","title":"[Python] ThreadPoolExecutor延时接受新job？","userId":"fireattack","userName":"烈之斩","userSign":"(V1046-R MAHORO)"}