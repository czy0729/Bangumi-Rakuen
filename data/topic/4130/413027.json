{"id":413027,"avatar":"//lain.bgm.tv/pic/user/m/000/37/04/370405.jpg","floor":"#1","group":"LLM记录","groupHref":"/group/llm_record","groupThumb":"","message":"While not all recursive algorithms can be easily transformed into iterative solutions, most can be refactored into iterations. Here are several examples of common recursive algorithms and their iterative counterparts:<br><br><span style=\"font-weight:bold;\">1. Factorial Calculation</span><br><br>Recursive:<br><div class=\"codeHighlight\"><pre>function factorial(n) {<br>    if (n === 0) return 1;<br>    return n * factorial(n - 1);<br>}</pre></div><br><br>Iterative:<br><div class=\"codeHighlight\"><pre>function factorial(n) {<br>    let result = 1;<br>    while (n > 0) {<br>        result *= n;<br>        n--;<br>    }<br>    return result;<br>}</pre></div><br><br><span style=\"font-weight:bold;\">2. Fibonacci Sequence</span><br><br>Recursive:<br><div class=\"codeHighlight\"><pre>function fibonacci(n) {<br>    if (n <= 1) return n;<br>    return fibonacci(n - 1) + fibonacci(n - 2);<br>}</pre></div><br><br>Iterative:<br><div class=\"codeHighlight\"><pre>function fibonacci(n) {<br>    let a = 0, b = 1, temp;<br>    while (n > 0) {<br>        temp = a;<br>        a = b;<br>        b = temp + b;<br>        n--;<br>    }<br>    return a;<br>}</pre></div><br><br><span style=\"font-weight:bold;\">3. Binary Tree Traversal (In-Order)</span><br><br>Recursive:<br><div class=\"codeHighlight\"><pre>function inOrderTraversal(node) {<br>    if (node !== null) {<br>        inOrderTraversal(node.left);<br>        console.log(node.value);<br>        inOrderTraversal(node.right);<br>    }<br>}</pre></div><br><br>Iterative:<br><div class=\"codeHighlight\"><pre>function inOrderTraversal(root) {<br>    let stack = [], current = root;<br>    while (stack.length > 0 || current !== null) {<br>        while (current !== null) {<br>            stack.push(current);<br>            current = current.left;<br>        }<br>        current = stack.pop();<br>        console.log(current.value);<br>        current = current.right;<br>    }<br>}</pre></div><br><br><span style=\"font-weight:bold;\">4. Depth-First Search (DFS)</span><br>Recursive:<br><div class=\"codeHighlight\"><pre>function dfs(node) {<br>    if (node !== null) {<br>        console.log(node.value);<br>        dfs(node.left);<br>        dfs(node.right);<br>    }<br>}</pre></div><br><br>Iterative:<br><div class=\"codeHighlight\"><pre>function dfs(root) {<br>    let stack = [root];<br>    while (stack.length > 0) {<br>        let node = stack.pop();<br>        if (node !== null) {<br>            console.log(node.value);<br>            stack.push(node.right);<br>            stack.push(node.left);<br>        }<br>    }<br>}</pre></div><br><br><span style=\"font-weight:bold;\">5. Tower of Hanoi</span><br>Recursive:<br><div class=\"codeHighlight\"><pre>function towerOfHanoi(n, fromRod, toRod, auxRod) {<br>    if (n === 1) {<br>        console.log(`Move disk 1 from rod ${fromRod} to rod ${toRod}`);<br>        return;<br>    }<br>    towerOfHanoi(n - 1, fromRod, auxRod, toRod);<br>    console.log(`Move disk ${n} from rod ${fromRod} to rod ${toRod}`);<br>    towerOfHanoi(n - 1, auxRod, toRod, fromRod);<br>}</pre></div><br><br>Iterative:<br><br>Transforming the Tower of Hanoi into an iterative solution is complex and less intuitive, but it is possible using stacks to simulate the call stack of the recursive algorithm. This typically involves a more intricate setup than what can be easily shown here, but for many simple recursive problems, an iterative solution is both feasible and practical.","time":"2024-12-28 23:54","title":"几种经典算法的递归和迭代写法","userId":"inchei","userName":"茵陳","userSign":"(Hello darkness my old friend)"}