{"id":19180,"avatar":"//lain.bgm.tv/pic/user/m/000/01/61/16138.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"我快被室友的代码搞疯了...<br><br>求大牛说说可能的原因是啥吧...<br>int Ackerman(int m,int n)<br>{<br>    seqStack <int> c;<br>    c.push(254);<br>    return 0;<br>    //奇怪的是我把后面这一部分没运行到的代码注释掉的话就能返回正确结果<br>    while(!c.isEmpty()){<br>    int tmp2=c.pop();<br>    if(c.isEmpty())<br>    return 0;<br><br>    int tmp1=c.pop();<br>    if(tmp1==0) c.push(tmp2+1);<br><br>    else if(tmp2==0){c.push(tmp1-1);c.push(1);}<br><br>    else {<br>        c.push(tmp1-1);<br>        c.push(tmp1);<br>        c.push(tmp2-1);}<br>    }<br>}<br><br>以下seqStack的定义<br>template <class T><br>class stack<br>{public:<br>virtual bool isEmpty() const=0;<br>virtual void push(const T&x)=0;<br>virtual T pop()=0;<br>virtual T top() const=0;<br>virtual ~stack(){}<br>};<br><br>template <class T><br>class seqStack:public stack <T><br>{private:<br>T *elem;<br>int top_p;<br>int maxSize;<br><br>void doubleSpace();<br><br>public:<br>seqStack(int initSize=10){<br>    elem=new T[initSize];<br>    maxSize=initSize;<br>    top_p=-1;<br>    }<br>~seqStack() {delete [] elem;}<br><br>bool isEmpty() const{return top_p==-1;}<br><br>void push(const T &x)<br>{<br>    if(top_p==maxSize-1)<br>      doubleSpace();<br>    elem[++top_p]=x;<br>}<br>T pop(){return elem[top_p--];}<br>T top() const{return elem[top_p];}<br>};<br>template <class T><br>void seqStack <T>::doubleSpace()<br>{<br>    T *tmp=elem;<br>    elem=new T [2*maxSize];<br>    for(int i=0;i<maxSize;i++)<br>    elem<span style=\"font-style:italic\">=tmp<span style=\"font-style:italic\">;<br>    delete [] tmp;<br>    maxSize*=2;<br>}<br><br>最后return 0之前做的事情就只有调用seqStack c的析构函数了，<br>我试过把两个~seqStack和~stack都去掉那么也能返回正常的结果<br>但是我实在看不出析构哪儿写错了...<br><br>另外如果把return 0之前那句push去掉的话...也是能返回正确结果的 </span></span>","time":"2012-10-15 21:28","title":"C++ 某函数return 0得到的结果却不是0","userId":"elwin","userName":"xdddddd","userSign":"(the x makes it sound cool)"}