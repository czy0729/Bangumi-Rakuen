{"id":373209,"avatar":"//lain.bgm.tv/pic/user/m/000/45/19/451958.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"<span style=\"font-size:25px; line-height:25px;\">解决方案：</span><br><div class=\"codeHighlight\"><pre>        from win32 import win32api, win32gui, win32print<br>        import win32con  # 为了得到两个常量，可以不导入<br>        # 获取所有逻辑屏幕的信息，得到虚拟分辨率和逻辑监视器句柄 hMonitor<br>        # 逻辑监视器信息(tuple): (hMonitor句柄, hdcMonitor没卵用, PyRECT包围盒)<br>        scInfos = win32api.EnumDisplayMonitors()<br>        for index, sc in enumerate(scInfos):<br>            # 获取设备信息字典，得到设备名称 Device<br>            # 物理设备信息(dict) = GetMonitorInfo(hMonitor)<br>            info = win32api.GetMonitorInfo(sc[0])<br>            # 为显示设备创建设备上下文，得到物理设备句柄 hDC<br>            # 设备句柄(int) = CreateDC (设备名称, 设备名称 , None )<br>            hDC = win32gui.CreateDC(info['Device'], info['Device'], None)<br>            w = win32print.GetDeviceCaps(hDC, win32con.DESKTOPHORZRES)<br>            h = win32print.GetDeviceCaps(hDC, win32con.DESKTOPVERTRES)<br><br>            print(f'第{index}号屏幕：')<br>            print(f'设备名称：{info[\"Device\"]}')<br>            print(f'物理分辨率 w: {w}   h: {h}')<br>            print(f'逻辑分辨率 w: {sc[2][2]-sc[2][0]}   h: {sc[2][3]-sc[2][1]}')<br>            print(f'逻辑坐标系 x: {sc[2][0]}   y: {sc[2][1]}')<br>            print()</pre></div><br><br>==================== 坑点 =============================<br><br>设备名称一定要用 GetMonitorInfo 获取。用 EnumDisplayDevices 得到的设备名称是错的（或者说，index对应的不是正在使用的物理显示器）！<br><div class=\"codeHighlight\"><pre># 获取第二块屏幕的名称<br>index = 1 # 第二块屏幕<br><br>device = win32api.EnumDisplayDevices(DevNum=index)   #  错！！<br>print(f'设备名称：{device.DeviceName}') # 这个DeviceName是不能被CreateDC识别的！<br><br>info = win32api.GetMonitorInfo( win32api.EnumDisplayMonitors()[index][0] )  # 对！<br>print(f'设备名称：{info[\"Device\"]}')           # 这个Device才能被CreateDC识别！<br></pre></div><br>==================== 以下原帖 =============================<br><br>我正在写一个选区截图模块，目标之一是能适配多屏幕。<br><br>我的思路是获取整块虚拟屏幕（所有屏幕拼起来的画面）的完整截图。然后创造一个置顶的无边框窗口，窗口的左上角设为虚拟屏幕的左上角，窗口的宽高设为虚拟屏幕的宽高，然后在窗口上显示完整截图。这样，截图的位置就能与每个显示器的位置相对应。最后，监听鼠标拖拽来获取截图选区。<br><br>目前，<a href=\"https://github.com/hiroi-sora/Umi-OCR/blob/main/ui/win_screenshot.py\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">我的代码</a>在单块屏幕或多块同缩放比例的屏幕上工作良好。（缩放比例即为windows的更改文本、应用等项目的大小）。但是，当其中一块屏幕的缩放比例与其他不同时，我的程序会出现显示错位的情况；原因是  EnumDisplayMonitors() 只能获取每块屏幕的逻辑分辨率(缩放后)。也许需要获取物理分辨率或缩放系数来配合调整。<br><br>用这一段代码可以获得主屏幕的物理分辨率，但是似乎没办法获取其他屏幕。将 EnumDisplayMonitors 得到的第二屏幕的句柄填入 GetDC 或 GetDeviceCaps 似乎也不起作用。<br><div class=\"codeHighlight\"><pre>hDC = win32gui.GetDC(0)<br>w = win32print.GetDeviceCaps(hDC, win32con.DESKTOPHORZRES)<br>h = win32print.GetDeviceCaps(hDC, win32con.DESKTOPVERTRES)</pre></div><br><br>所以求个助，有什么办法可以获取多屏幕的物理分辨率 or 缩放系数呢？或者说我截图模块的设计思路不对，有更好的思路呢？ ","time":"2022-9-22 11:14","title":"【基本解决】win32api 获取第二块显示器的物理分辨率","userId":"451958","userName":"冈崎羽未鹰原汐","userSign":"(二阶堂芽爱 小河坂青空)"}