{"id":407333,"avatar":"//lain.bgm.tv/pic/user/m/000/21/27/212710.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"* 本文也贴在了老版yu-no的评论区。<br><br>在yu-no这个galgame的流程里面，有这样一个的谜题：在一个12x12的棋盘上，每个格子可以被点亮。对于每行每列我们已知一个列表，标记了连续被点亮的格子的数量。例如，[2,7]代表这一行列中先有2个连续的格子被点亮，后又7个连续的格子被点亮，二者之间至少有一个没有被点亮的格子。求棋盘中每个格子的状态。<br><br><img src=\"https://i0.hdslb.com/bfs/article/watermark/8ba42c75c9a1feff04eb39c18db83b719ca98f2b.png@1256w_876h_!web-article-pic.avif\" class=\"code\" rel=\"noreferrer\" referrerpolicy=\"no-referrer\" alt><br><br>看到这种问题，总之先试着丢给smt solver:<br>   <br><div class=\"codeHighlight\"><pre><br>from z3 import *<br>import numpy as np<br><br>board = np.zeros((12, 12), dtype=object)<br><br>for i in range(12):<br>    for j in range(12):<br>        board[i, j] = Bool(f\"cell_{i}_{j}\")<br><br># build rules<br>def build_rule(base, rlist):<br>  min_size = sum(rlist) + len(rlist) - 1<br><br>  rules = []<br>  for start in range(base, 12 - min_size + 1):<br>    # place the head<br>    place_head = [start + i for i in range(rlist[0])]<br>  <br>    if len(rlist) == 1:<br>      rules.append(place_head)<br>    else:<br>      tail_index = start + rlist[0] + 1<br>      for rule in build_rule(tail_index, rlist[1:]):<br>        rules.append(place_head + rule)<br>    <br>  return rules<br><br>def build_constraint(indexer, rules):<br>  constraints = []<br>  for r in rules:<br>    c = [indexer[i] == False if i in r else indexer[i] == True for i in range(12)]<br>    constraints.append(And(*c))<br>  return Or(*constraints)<br><br>s = Solver()<br><br># right rules. left inverse all codes<br>yrules = [[2], [1,4], [3], [2], [2,5], [2,6], [6,2], [5,2], [2], [3], [4,1], [2]]<br>xrules = [[1], [2], [2,2], [1,2], [7,1], [2,5,2], [2,5,2], [1,7], [2,1], [2,2], [2], [1]]<br><br>for i in range(12):<br>  s.add(build_constraint(board[i], build_rule(0, xrules[i])))<br>  s.add(build_constraint(board[:, i], build_rule(0, yrules[i])))<br><br>s.check()<br>s.model()<br><br>for i in range(12):<br>  for j in range(12):<br>    b = s.model()[board[i, j]]<br>    print('o' if b else 'x', end=' ')<br>  print()<br></pre></div><br><br>运行，给出的答案就是正解。至于是不是只有一个解(model counting)，留作练习。如果是人肉推理的话应该更容易看出来是不是唯一解吧。不过现在我已经能GPT能敲代码就放弃思考了）","time":"2024-10-13 14:20","title":"用python破解yu-no中地下石窟的谜题吧！","userId":"depct","userName":"Depicture","userSign":""}