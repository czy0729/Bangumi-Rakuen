{"avatar":"//lain.bgm.tv/pic/user/m/000/44/95/449556.jpg","floor":"#1","group":"班固米算法学社","groupHref":"/group/algorithm_society","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/43/4386.jpg?r=1590600507","message":"这周是摸鱼的一周，没学啥东西，打了两场cf。<br>其实没摸鱼，主要是期末了，有大作业要整。<br>还是直接说主题吧。<br><br><br><br><span style=\"font-size:24px; line-height:24px;\">如何线性求多个数的逆元</span><br><br>当然是指模质数意义下的乘法逆元。<br><br>众所周知我们可以线性时间复杂度求 1~n 这 n 个数的逆元，也可以线性求这 n 个数的阶乘的逆元，这都是非常普及的科技。<br><br>求多个无规律的数的逆元是对阶乘逆元的推广。众所周知阶乘逆元只需要求 n! 的逆元然后乘回去：<br><br><div class=\"codeHighlight\"><pre><br>void init () {<br>        fac[0] = 1;<br>        for (int i = 1;i <= n;++i) {<br>                fac[i] = fac[i - 1] * i;<br>        }<br>        inv[n] = getinv(fac[n]);<br>        for (int i = n - 1;i >= 0;--i) {<br>                inv[i] = inv[i + 1] * (i + 1);<br>        }<br>}<br></pre></div><br><br>getinv() 就不写了，大家都会，不会就找博客看吧。<br><br>考虑推广这个过程到无规律的数。观察这个过程，我们发现阶乘是一种特殊的前缀积，而这个过程对任意的前缀积都能做。另外模质数意义下的乘法逆元是完全积性的，这就是说前缀积的逆元就是逆元的前缀积。于是我们可以线性求前缀积逆元，而每个数的逆元又可以由前缀积和前缀积逆元 O(1) 计算。<br><br><div class=\"codeHighlight\"><pre><br>void init () {<br>        for (int i = 1;i <= n;++i) {<br>                pre[i] = pre[i - 1] * a[i] % mod;<br>        }<br>        preinv[n] = getinv(pre[n]);<br>        for (int i = n - 1;i >= 1;--i) {<br>                preinv[i] = preinv[i + 1] * a[i + 1] % mod;<br>        }<br>        for (int i = 1;i <= n;++i) {<br>                inv[i] = pre[i - 1] * preinv[i] % mod;<br>        }<br>}<br></pre></div><br><br>这个科技的模板题参考 Luogu5431，但出题人卡常，非常卡的那种，我觉得过不了就算了。反正我卡不过去，你说卡常有啥意义，非要卡。<br><br><br><br><span style=\"font-size:24px; line-height:24px;\">线段树如何维护半群上的运算</span><br><br>不是什么新东西，可能大家都会，想写只是因为最近我对线段树的这些理解是最近才想明白的。<br><br>线段树区间加区间乘区间求和区间最值之类的大家都会，不会就找博客看吧。但更进一步地，这些运算的共同点是可结合性，而事实上即使定义一些新的可结合的运算线段树也能维护。<br><br>来个具体的题目比较好解释。<br><br><div class=\"codeHighlight\"><pre><br>有n个字符串排成一排，每个字符串初始为空。现在要进行m次以下操作：<br>操作1：把一个[l,r]区间里所有字符串前面加上一位十进制数字，后面加上一位十进制数字。比如”44”这个字符串“加上”5后，就变成了”5445”.<br>操作2：求[l,r]区间里所有字符串代表的数字之和对10^9+7取余后的结果。特别地，空串代表0。<br>1≤n≤10^5，1≤m≤10^5<br></pre></div><br><br>如何维护操作 2 的 sum 呢？对于当前一个 d 位的数 x 我要在首尾添加一个 y，这其实是在说 x = y * 10 ^ (d + 1) + x * 10 + y，也就是区间加 y * (10 ^ (d + 1) + 1)。考虑每个结点开一个数据域 v 代表区间最高位和，即 v = \\sum_{i=l}^{r} 10 ^ (d_i + 1)，我们也就可以在线段树上维护区间 sum 了。<br><br>再考虑 lazy tag。一次 pushdown 可能给儿子添加不止一位而是很多位 y，所以我们需要维护两个 tag：下传数据时对儿子应添加的前缀 pre 和后缀 suf。而下传的过程中，儿子的数据与 tag 的更新必须要知道当前节点的 tag 的位数和儿子的 tag 的位数才能快速进行，因此我们维护一个 tag 的 tag：pre/suf 的位数 dig。<br><br>我们发现以上所有数据和标记的上下传操作都只用到加法和乘法，所以都是可结合的，所以我们在一棵普通的线段树上改改就可以了。就只展示关键部分（上下传）的代码，不然太长。<br><br><div class=\"codeHighlight\"><pre><br>void pushup (int u) {<br>        t[u].sum = (t[lc].sum + t[rc].sum) % mod;<br>        t[u].v = (t[lc].v + t[rc].v) % mod;<br>}<br><br>void pushdown (int u) {<br>        t[lc].sum = (t[lc].v * t[u].dig % mod * t[u].pre<br>                        + t[lc].sum * t[u].dig<br>                        + (t[lc].r - t[lc].l + 1) * t[u].suf % mod) % mod;<br>        t[lc].v = (t[lc].v * t[u].dig % mod * t[u].dig) % mod;<br>        t[lc].pre = (t[lc].dig * t[u].pre + t[lc].pre) % mod;<br>        t[lc].suf = (t[lc].suf * t[u].dig + t[u].suf) % mod;<br>        t[lc].dig = (t[lc].dig * t[u].dig) % mod;<br>        t[rc].sum = (t[rc].v * t[u].dig % mod * t[u].pre<br>                        + t[rc].sum * t[u].dig<br>                        + (t[rc].r - t[rc].l + 1) * t[u].suf % mod) % mod;<br>        t[rc].v = (t[rc].v * t[u].dig % mod * t[u].dig) % mod;<br>        t[rc].pre = (t[rc].dig * t[u].pre + t[rc].pre) % mod;<br>        t[rc].suf = (t[rc].suf * t[u].dig + t[u].suf) % mod;<br>        t[rc].dig = (t[rc].dig * t[u].dig) % mod;<br>        <br>        t[u].pre = t[u].suf = 0;<br>        t[u].dig = 1;<br>}<br></pre></div><br><br>这是 CCPC 2018 Jilin 的 H，即 HDU6562，欢迎大家去交。<br><br>确实稍微有点难读，这里只能祝大家写线段树毒瘤题的时候身体健康了。总之，只要想清数据与标记的上下传，我们发现线段树总是可以维护半群上的运算。<br><br><br><br>哇，写得比我想象中的慢，不想写了，懒了，就这样吧，我还有大作业没整，以后有空也许会多写。 ","time":"2020-6-13 01:40","title":"[20200613] 简单分享最近学习的科技","userId":"nanakom","userName":"Nanakom","userSign":"(给分主观的低端萌豚而已)"}