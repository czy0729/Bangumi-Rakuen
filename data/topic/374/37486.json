{"id":37486,"avatar":"//lain.bgm.tv/pic/user/m/000/00/35/3556.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"当然在 Swift 这种现代语言下还用过去的 pointer 操作这本身就是一个很奇怪的行为这点偶也深切理解<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">但是没办法因为移植前的东西是 C++ 写的到处都是 pointer 操作又没有文档告诉偶规格只能尽量在代码上遵循以前的操作于是只好想办法在 Swift 下模拟出这些操作了<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"><br><br>目前偶想到的放法就是利用 Swift 强大的 struct 来解决这个问题，至于为什么用 struct 不用 class，原因是因为理论上 struct 比 class 更轻量，虽然偶没测试过具体在执行效率上跟 class 是否有差别<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">只是当然因为 C++ 这类语言的话 pointer 都是 reference 所以如果以前的操作有大量的复制 pointer 的操作的话或许可能用 class 会更方便？<br><br>嘛不多说了，话说 Swift 的 struct 真是非常强大，居然可以定义 computed property 和 function 进去<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">首先偶们要做的就是定义一个 struct：<br><br>struct LegacyFileType {<br>    let buff = NSData()<br>    var pointer = 0<br><br>    func pointerValue(step: Int = 0) -> Byte {<br>        let rangeLoc = pointer + step<br>        var value: Byte = 0<br>        if rangeLoc + sizeof(Byte) < buff.length {<br>            let range = NSMakeRange(rangeLoc, sizeof(Byte))<br>            buff.getBytes(&value, range: range)<br>        }<br>        return value<br>    }<br>}<br><br>这样就完成了一个最基本的 struct 的结构；这里面 pointerValue 这个 func 之所以会有个 step 这个参数原因是因为在 C/C++ 里面很多时候会用 p[1] 这样的方式来取值所以这里提供一个取 pointer + offset 的位置的值的方式 w<br><br>于是这样在创建一个物体的时候就可以在初始化时将文件转换为 NSData 来存储，比如这样：<br>let fileName = \"test.abc\"<br>let fileURL = NSBundle.mainBundle().URLForResource(fileName, withExtension: nil)!<br>let data = NSData(contentsOfURL: fileURL)!<br><br>var legacyFile = LegacyFileType(buff: data, pointer: 0)<br><br>于是这样的话无论偶们怎么样设置 legacyFile.pointer 的值，都可以利用 legacyFile.pointerValue(step: 1) 来获取当前 pointer 的值（因为在定义里面已经给了 step: Int = 0 的默认值，所以如果不需要 offset，也就是 C/C++ 里面 *p 的写法的话也可以省略 step 直接写 legacyFile.pointerValue()）<br><br>嘛当然相比起 C++ 的代码来说肯定是长了不少（毕竟人家不支持 pointer 操作<img src=\"/img/smiles/tv/16.gif\" smileid=\"55\" alt=\"(bgm39)\">），8过好处是因为可以在 pointerValue 里面验证 pointer 的地址所以理论上不存在 pointer 坐标（？）不存在的问题 w<br><br>顺便一说，有时候会需要取连续多字节来求值（比如 int32 的话就是4字节），这样的话还可以扩充一下 pointerValue 的 function 给他添加一个 length 的参数来写入 &value，然后如果涉及到 Endian 的问题的话也可以代入后在写一个 value = value.bigEndian（因为 iOS 在代入时是 little endian 方式代入，所以只有 big endian 保存的时候才需要这样做）就可以搞定，从这个意义上说这比在 C/C++ 下用 value = p[0]<<24 + p[1]<<16 + p[2]<<8 + p[3]的写法可能相对来说还是看着好看一点<img src=\"/img/smiles/tv/16.gif\" smileid=\"55\" alt=\"(bgm39)\"><br><br>不知道小伙伴们还有没有更聪明的模拟 pointer 操作的写法<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">反正作为一个二把刀的程序猿偶能想到的就是这个了<br><br><br><br>===========2014/12/21更新===========<br><br>突然发现原来 Swift 还有一个 subscript 的功能似乎看起来会更好看<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">明天上班测试一下<br><br><br>===========2014/12/22更新===========<br><br>发现原来 Swift 还有 subscript 这个神奇的功能<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">于是尝试了一下<br><br>写法很简单，如果沿用 pointerValue 这个 func 的话只需要在 struct 定义里面追加一个<br><br>subscript(index: Int) -> Byte {<br>    return pointerValue(step: index)<br>}<br><br>即可；当然嫌这样太长的话也可以把 return 部分替换成 pointerValue 的定义然后删掉 pointerValue 这个 func 就行；这样写的好处是在引用的时候只需要写<br>legacyFile[0]<br>legacyFile[1]<br>这样就可以获取当前 pointer 及 offset 位置的 Byte 值，因为用的是[]而不是()所以看上去至少跟 C 的 ptr[0] 这样的写法比较像；当然缺点就是这样的话就没法获取多字节长度的返回值，以及如果这个文件里面有多个 pointer 的话就没法应对了<br>（其实准确来说也不是没有办法，subscript 虽然不支持标签但支持多参数，只是硬生生地加上多参数支持的意义不大，因为 subscript 的参数不支持默认值必须写上全部参数，于是引用时就是<br>legacyFile[\"pointerA\", 0, 1]<br>这样的写法了，看上去非常难懂没有任何使用 subscript 的意义）<br><br>===========2014/12/22更新2===========<br><br>刚才说无法获取多字节长度的问题，现在发现原来这个问题可以解决，方法也很简单，只需要再写一个 subscript 就行了，写法如下：<br><br>subscript(range: Range<Int>) -> Int {<br>    let start = range.startIndex<br>    let length = range.endIndex - range.startIndex<br>    <br>    return pointerValue(step: start, length: length)<br>}<br><br>即可，需要注意的是这里返回值不是 Byte 而是 Int，因为这里需要获取的是多字节长度的 Int 值；同理 pointerValue 这个 func 也要跟着修改成返回值为 Int 的 func；然后在引用时的写法是<br><br>legacyFile[0..<4]<br><br>这样就可以获取一个4字节长度的 Int 值了<br>（两个 subscript 同时存在没有问题因为两者使用的参数类型不一样，所以 legacyFile[0] 和 legacyFile[0..<4] 两个可以同时使用） ","time":"2014-12-19 17:51","title":"【12/22更新】Swift 下利用 struct 和 NSData 模拟 pointer 操作","userId":"lovee","userName":"星野恵瑠","userSign":"(Miata Is Always The Answer!)"}