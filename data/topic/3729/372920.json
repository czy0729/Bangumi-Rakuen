{"id":372920,"avatar":"//lain.bgm.tv/pic/user/m/000/45/19/451958.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"平台：Windows 10<br>版本：opencv460，C++<br><br>==================== 解决方案 =====================<br><br><div class=\"codeHighlight\"><pre>#include<codecvt><br>std::wstring_convert<std::codecvt_utf8<wchar_t>> convU8toWstr; // string u8\"\" 到wstring的转换器<br><br>// 代替 cv::imread ，从路径path读入一张图片。path必须为utf-8的string<br>cv::Mat imread_utf8(string pathU8, int flags = cv::IMREAD_COLOR) {<br>  // string u8 转 wchar_t<br>  std::wstring wpath;<br>  try {<br>        wpath = convU8toWstr.from_bytes(pathU8); // 利用转换器转换<br>  }catch (...) {<br>        return cv::Mat();<br>  }<br>  // 打开文件<br>  FILE* fp = _wfopen((wchar_t*)wpath.c_str(), L\"rb\"); // wpath强制类型转换到whar_t<br>  if (!fp) { // 打开失败<br>        return cv::Mat();<br>  }<br>  // 将文件读到内存<br>  fseek(fp, 0, SEEK_END); // 设置流 fp 的文件位置为 SEEK_END 文件的末尾<br>  long sz = ftell(fp); // 获取流 fp 的当前文件位置，即总大小（字节）<br>  char* buf = new char[sz]; // 存放文件字节内容<br>  fseek(fp, 0, SEEK_SET); // 设置流 fp 的文件位置为 SEEK_SET 文件的开头<br>  long n = fread(buf, 1, sz, fp); // 从给定流 fp 读取数据到 buf 所指向的数组中，返回成功读取的元素总数<br>  cv::_InputArray arr(buf, sz); // 将只读输入数组传递到OpenCV函数<br>  cv::Mat img = cv::imdecode(arr, flags); // 解码内存数据，变成cv::Mat数据<br>  delete[] buf; // 释放buf空间<br>  fclose(fp); // 关闭文件<br>  return img;<br>}<br></pre></div><br><br>使用示例：<br><div class=\"codeHighlight\"><pre><br>string img_path = u8\"D:/测试图片.png\"; // 必须为utf-8字符串<br>cv::Mat srcimg = imread_utf8(img_path);<br>if (srcimg.data) {<br>// 执行你的任务<br>}<br></pre></div><br><br>==================== 以下原帖 =====================<br><br>我发现imread似乎要求filename这个字符串的编码与当前系统语言地区编码一致。假如当前系统语言是简体中文，即系统编码为gbk (cp936) ，那么传入utf-8的filename会使imread无法识别，只有gbk编码的filename才行。<br>反之，若当前Windows勾选了“使用UTF-8提供全球语言支持”，即系统编码为utf-8（cp65001），那么只能传入utf-8编码的filename。<br><br>插播，Windows查看系统地区编码的方式：<br>1. 打开cmd，输入chcp<br>2. Python的<a href=\"https://docs.python.org/zh-cn/3.8/library/locale.html#locale.getdefaultlocale\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">getdefaultlocale</a><br><br>回归正题。我希望程序能在所有的系统地区语言上跑起来，比如日文cp932、西欧cp1252等等。<br>那么，我是不是应该先将目标filename（utf-8）转码成对应的系统编码，再传入 imread ？<br><br>这引发了两个主要问题：<br>1. C++下有啥可用的编解码库，可以实现如此多种编码的互转？<br>2. 是不是意味着 imread 不可能读入 <span style=\"font-weight:bold;\">含有超出此编码的字符</span> 的路径？比如系统编码是cp1252，<span style=\"font-weight:bold;\">含中文的utf-8字符串不可能转码为cp1252</span>，那不管怎么整 都没有办法把中文路径弄进 imread<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"> ","time":"2022-9-10 10:03","title":"【已解决】Opencv在非中文Windows 10系统语言区域下以utf-8中文路径字符串读取图片","userId":"451958","userName":"冈崎羽未鹰原汐","userSign":"(二阶堂芽爱 小河坂青空)"}