{"id":369541,"avatar":"//lain.bgm.tv/pic/user/m/000/31/77/317704.jpg","floor":"#1","group":"～技术宅真可怕～","groupHref":"/group/a","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/00/11.jpg","message":"<span style=\"font-weight:bold;\">已解决</span><br><span style=\"font-weight:bold;\">文章：<a href=\"https://nekonull.me/posts/py-itertools-permutation-algo/\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">Python `itertools.permutations` 使用的排列算法</a></span><br><span style=\"font-weight:bold;\">视频：<a href=\"https://www.youtube.com/watch?v=jUM_Dpt6yu0\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">Permutations - A Python itertools Algorithm - mCoding</a></span><br><br>---<br><br>最近在算法复健，刷题时偶尔遇到了排列相关的题，自己用的一般要么是 DFS，要么是字典序。突然想起来 Python 的自带库 itertools 里有一个 permutations 方法，于是想看看是怎么实现的。官方文档中给了一个和 <a href=\"https://github.com/python/cpython/blob/1f21eaa15e8a0d2b0f78d0e3f2b9e5b458eb0a70/Modules/itertoolsmodule.c#L3075\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">CPython 实现</a>等价的 <a href=\"https://docs.python.org/zh-cn/3/library/itertools.html#itertools.permutations\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">Python 代码实现</a> ，然而代码注释甚少，有些难懂。<br><br>一番搜索之后，找到了两个相关的解析，分别来自 <a href=\"https://stackoverflow.com/questions/2565619/algorithm-for-python-itertools-permutations\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">Stack Overflow</a> 和 <a href=\"https://www.zhihu.com/question/440688033\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">知乎</a>。前者说这个算法用到了一些 Permutation Cycle 的知识，恶补了一番相关数学后感觉关系不大，评论里也有说学了 6 年抽象代数但是并不觉得算法与之相关的。后者说这本质上是个递归优化，但是感觉思路不是很明确，不知道是如何得出的。此外也尝试直接搜索 `python itertools permutation how it works`，然而 Google 翻到底了似乎也没有比较好的解析。<br><br>根据 Stack Overflow 的回答，我自己加了几个 print 把中间状态打出来，自己在草稿纸上手动 trace。现在大概知道这算法是怎么工作的了，不过依然只有一个很模糊的直观感受，不是很透彻。<br>- 每次输出时 yield 只是把 indexes 的前 r 个元素取出来，<br>- cycles 的变化和倒计时类似，每次每个后面的元素为 0 就会对前面的元素 -1<br>- 而 cycles 对 indexes 的修改就类似于打麻将时对牌的整理，一般情况下交换两个元素的位置，某个 cycles 元素为 0 时把中间一项拿出来放到最后。<br><br>然而直觉也就止步于 r=2 的情况了，元素更多就想象不出来了。<br><br>还请 Bangumi 技术大佬赐教！<br><br>相关代码附注于下：（也可访问  <a href=\"https://docs.python.org/zh-cn/3/library/itertools.html#itertools.permutations\" target=\"_blank\" rel=\"nofollow external noopener noreferrer\" class=\"l\">Python Itertools 文档</a>  ）<br><br><div class=\"codeHighlight\"><pre><br>def permutations(iterable, r=None):<br>    # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC<br>    # permutations(range(3)) --> 012 021 102 120 201 210<br>    pool = tuple(iterable)<br>    n = len(pool)<br>    r = n if r is None else r<br>    if r > n:<br>        return<br>    indices = list(range(n))<br>    cycles = list(range(n, n-r, -1))<br>    yield tuple(pool[i] for i in indices[:r])<br>    while n:<br>        for i in reversed(range(r)):<br>            cycles[i] -= 1<br>            if cycles[i] == 0:<br>                indices[i:] = indices[i+1:] + indices[i:i+1]<br>                cycles[i] = n - i<br>            else:<br>                j = cycles[i]<br>                indices[i], indices[-j] = indices[-j], indices[i]<br>                yield tuple(pool[i] for i in indices[:r])<br>                break<br>        else:<br>            return<br></pre></div> ","time":"2022-5-8 19:50","title":"(已解决) Python itertools.permutations 使用的算法？","userId":"317704","userName":"NekoNull","userSign":""}