{"id":17719,"avatar":"//lain.bgm.tv/pic/user/m/000/00/25/2594.jpg","floor":"#1","group":"靠谱人生茶话会","groupHref":"/group/boring","groupThumb":"//lain.bgm.tv/pic/icon/m/000/00/03/364.jpg","message":"<span style=\"background-color:#555;color:#555;border:1px solid #555;\">因为晚上这个实际上是利用了cookie漏洞，套用了其他用户的cookie，可以用来做很可怕的坏事，所以就不能贴代码了，改为和大家分享几点经验好了。<br><br>1、尽量自动化，但不要过早升级军备<br>最早4天前开始刷的时候用的是selenium ide的流程脚本，人工识别输入验证码，根据人工效率，大概是每20秒一票，我忘了兔喵姐姐刷到多少票，反正挺辛苦了，现在看来真不值<br>昨天早上前改为了用python调用selenium配合ocr的自动识别刷票，大概能做到每5秒一票，这其实是对于刷票来说应该是绰绰有余了，如果我足够远见不冲动的话应该保持在这个阶段就好了<br>然后今天早上放弃了selenium，改以urllib为基础发起请求，配合ocr识别，速度达到每秒2票左右，而且可以多开，开5个进程的话就是每秒10票了<br>错就错在这一步，终于引起主办方注意了，主办方开始升级自己的防护措施，而且中午发现其他人的刷票速度也明显加快了，这就是主动开启军备竞赛的后果啊<br><br>2、http请求之间一定要延时<br>今天早上会被主办方盯上的原因就是http请求太快太多了，于是对方也各种升级，包括限制ip，禁止过快请求的方式<br>所以建议还是一开始考虑周全，虽然程序可以做到高速，但是稍微低速一点不引人注意为好<br><br>3、用户名不要用miao+数字的形似<br>很容易被排查出来，然后全部删掉，最后添加为非法关键词<br>正确的做法是：<br><div class=\"\\\"codeHighlight\\\"\"><pre>nickname = \"\".join( [unichr(random.randint(0x4E00, 0x9FA5)) for i in xrange(random.randint(8, 15))] )<br></pre></div><br>4、代理<br><div class=\"\\\"codeHighlight\\\"\"><pre>def get_proxies():<br>  proxies_list = [] <br>  f = open('proxies.txt', 'r')<br>  for line in f:<br>    proxies_list.append(line.strip())<br>  proxy = random.choice(proxies_list)<br>  print 'using: ' + proxy<br>  proxies = {<br>     \"http\" : proxy<br>  }<br>  return proxies</pre></div><br>这样就可以在proxies.txt每行放置一个http代理地址，然后重复调用get_proxies都会重新读取并选取一个，交给urllib使用<br><br>5、花点时间研究漏洞<br>之前用selenium的土办法，算进输入验证码的人工成本，加上后来用ocr去识别验证码所消耗的测试时间<br>不要看到验证码就觉得很难，人工输入或者硬上，想办法绕过去！<br>如好好花一两个小时找找对方的漏洞，难保没有惊喜，例如可以达到每秒130票，这几乎就是网络连接速度的极限了<br><br>6、不要得意忘形，打持久战<br>通过这次被删教训，才发现用7000:2000的大比分领先别人是不好的，枪打出头鸟<br>比较好的做法应该是看对方刷到第一之后，再以比较小的优势反超<br>不要想着无情碾压什么的<br><br>7、坚持！但while True是不对的<br>所谓到高一尺魔高一丈，只要不断尝试一定能刷赢所有人的<br>但是有可能还是while miao < 500之类的比较好<br><br>完。</span> ","time":"2012-8-3 22:58","title":"[经验分享]while True: 刷！","userId":"aligo","userName":"‌aligo","userSign":""}