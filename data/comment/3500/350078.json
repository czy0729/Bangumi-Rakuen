[{"avatar":"//lain.bgm.tv/pic/user/m/000/13/30/133075.jpg","floor":"#2","id":"1432586","time":"2019-4-3 23:20","userId":"liaune","userName":"君寻","userSign":"(学会欣赏不完美)","message":"我猜是10次","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/29/76/297631.jpg","floor":"#2-1","id":"1433589","time":"2019-4-7 14:29","userId":"ydc123","userName":"ydc","userSign":"","message":"并不……就算是123456789123456789123456789都远不止10次<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/31/34/313469.jpg","floor":"#3","id":"1432589","time":"2019-4-3 23:28","userId":"313469","userName":"Cedar","userSign":"(｡´-д-)","message":"<span style=\"text-decoration: line-through;\">我百度到了一个结果<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"> 如果没错的话, 它的答案+1就是你的答案<br><a href=\"https://blog.csdn.net/jingsuwen1/article/details/51934277\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">https://blog.csdn.net/jingsuwen1/article/details/51934277</a></span><br>读题失败, 不是这个<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/26/79/267979.jpg","floor":"#4","id":"1432590","time":"2019-4-3 23:28","userId":"banixc","userName":"233","userSign":"","message":"抛砖引玉：<br>记忆化搜索，首先开一个哈希表，然后进入search函数：<br>遍历一遍字符串，以每个index为中心找最长的回文子串，（以及每个index，index+1为中心），删除中间的回文字串后递归调用search函数，返回的值是操作次数，然后这个函数中找操作次数的最小值，记录到哈希表里。<br>时间/空间复杂度：O(N^2)","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/13/30/133075.jpg","floor":"#4-1","id":"1432596","time":"2019-4-3 23:46","userId":"liaune","userName":"君寻","userSign":"","message":"然而删除最长的回文子串未必是每一轮的最优选择，也可能存在删除一个数而在下一轮得到更长的回文子串的情况"},{"avatar":"//lain.bgm.tv/pic/user/m/000/16/27/162791.jpg","floor":"#4-2","id":"1432600","time":"2019-4-3 23:48","userId":"wyxd","userName":"苇原雪道","userSign":"","message":"直接把最长回文串全删了不一定是最优解。比如<br>aaabaaaaaaaaaaaaaaaaaaaaaaaaaa，<br>直接把后面所有a全删了的话要三次，把aaabaaa删了的话只要两次。"},{"avatar":"//lain.bgm.tv/pic/user/m/000/26/79/267979.jpg","floor":"#4-3","id":"1432709","time":"2019-4-4 11:49","userId":"banixc","userName":"233","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">苇原雪道</span> 说: 直接把最长回文串全删了不一定是最优解。比如<br>aaabaaaaaaaaaaaaaaaaaaaaaaaaaa，<br>直接把后面所有a全删了的话要三次，把aaabaaa删了的话只要两次。</q></div>所以两种情况都要搜索一次<br>删除aaabaaa之后递归调用下这个函数<br>以及删除后面a之后递归调用下这个函数<br>分别比较这两种情况的返回值，然后选择最小的那个值+1作为返回值。"},{"avatar":"//lain.bgm.tv/pic/user/m/000/26/79/267979.jpg","floor":"#4-4","id":"1432710","time":"2019-4-4 11:52","userId":"banixc","userName":"233","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">君寻</span> 说: 然而删除最长的回文子串未必是每一轮的最优选择，也可能存在删除一个数而在下一轮得到更长的回文子串的情况</q></div>请看#4-3"},{"avatar":"//lain.bgm.tv/pic/user/m/000/13/30/133075.jpg","floor":"#4-5","id":"1432717","time":"2019-4-4 12:03","userId":"liaune","userName":"君寻","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">233</span> 说: 请看#4-3</q></div>这样的话每一轮都要遍历删除每个单数以及每个回文数的情况，时间复杂度是O(N!)，不可行啊"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/53/345353.jpg","floor":"#5","id":"1432591","time":"2019-4-3 23:32","userId":"a_researcher","userName":"揪卡","userSign":"","message":"应该就是这个思路吧，要么删掉一个，要么找右侧的该字符的某个occurrence然后分成两段<br><br>忽然发现你说的是正整数，是1,2,3,4,3这种每个数字小于10，还是1,2,34,5,43这种，其中34543算回文，或者1,2,34543这种单个数字算回文","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/34/53/345353.jpg","floor":"#5-1","id":"1432609","time":"2019-4-3 23:59","userId":"a_researcher","userName":"揪卡","userSign":"","message":"dp[i ][j] = min(1+dp[i+1][j], dp[i+1][k-1]+dp[k+1][j]) ?大概n^3……"},{"avatar":"//lain.bgm.tv/pic/user/m/icon.jpg","floor":"#5-2","id":"1432629","time":"2019-4-4 00:27","userId":"455308","userName":"TargetLocked","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">揪卡</span> 说: dp[i ][j] = min(1+dp[i+1][j], dp[i+1][k-1]+dp[k+1][j]) ?大概n^3……</q></div>看起来十分正确的样子……可能需要判一下k==i+1的情况……"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/53/345353.jpg","floor":"#5-3","id":"1432630","time":"2019-4-4 00:28","userId":"a_researcher","userName":"揪卡","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">TargetLocked</span> 说: 揪卡 说: dp[i ][j] = min(1+dp[i+1][j], dp[i+1][k-1]+dp[k+1][j]) ?大概n^3……看起来十分正确的样子……可能需要判一下k==i+1的情况……</q></div>哦哦是的，如果k==i+1就直接规约到1+dp[i+2][j]"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/36/06/360675.jpg","floor":"#6","id":"1432592","time":"2019-4-3 23:33","userId":"blackadder","userName":"Blackadder","userSign":"(In libris libertas.)","message":"发邮件问助教啊<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7","id":"1432594","time":"2019-4-3 23:42","userId":"windrises","userName":"windrises","userSign":"(一个纠结的面瘫伪宅)","message":"你确定是每次去掉一个回文子串而不是子序列？不过子序列感觉也不好做<br>显然是不能直接搞dp的，因为状态数会爆炸<br><br>我有个贪心的初步想法：<br>设原数组为S<br>反过来思考，设数组 P，初始为空<br>每次可以在当前数组 P 中某个位置处插入一个回文子串p，得到新的P<br>重复，最后使得P等于S<br>这样的话可以每次插入S中的一个最长的子序列，设为s 从S中去掉s来更新S<br>重复，最后使得S为空<br><br>寻找S的最长子序列是个很简单的dp问题就不用说了，问题是贪心不好证明<img src=\"/img/smiles/tv/16.gif\" smileid=\"55\" alt=\"(bgm39)\">","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/icon.jpg","floor":"#7-1","id":"1432607","time":"2019-4-3 23:57","userId":"455308","userName":"TargetLocked","userSign":"","message":"如果你的意思是原问题等价于每次删一个回文子序列的话，那好像不太对，因为给定一个删除子序列的方案并不能构造一个删除子串的方案使得步数相等……"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7-2","id":"1432608","time":"2019-4-3 23:58","userId":"windrises","userName":"windrises","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">TargetLocked</span> 说: 如果你的意思是原问题等价于每次删一个回文子序列的话，那好像不太对，因为给定一个删除子序列的方案并不能构造一个删除子串的方案使得步数相等……</q></div>那不是我的意思"},{"avatar":"//lain.bgm.tv/pic/user/m/000/31/78/317841.jpg","floor":"#7-3","id":"1432611","time":"2019-4-4 00:00","userId":"smileandyxu","userName":"smileandyxu","userSign":"","message":"感觉不对貌似<br>abacadaeafag，用最长子序列要7次，但顺着删只要6次"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7-4","id":"1432614","time":"2019-4-4 00:04","userId":"windrises","userName":"windrises","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">smileandyxu</span> 说: 感觉不对貌似<br>abacadaeafag，用最长子序列要7次，但顺着删只要6次</q></div>1、a a a d a a a <br>2、a b a a d a a a <br>3、a b a c a d a a a <br>4、a b a c a d a e a a <br>5、a b a c a d a e a f a <br>6、a b a c a d a e a f a g"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/53/345353.jpg","floor":"#7-5","id":"1432621","time":"2019-4-4 00:13","userId":"a_researcher","userName":"揪卡","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: 1、a a a d a a a <br>2、a b a a d a a a <br>3、a b a c a d a a a <br>4、a b a c a d a e a a <br>5、a b a c a d a e a ...</q></div>我还是不太明白你的方法，abacadaeacab你要怎么做呢？应该是4次吧？"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7-6","id":"1432623","time":"2019-4-4 00:18","userId":"windrises","userName":"windrises","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">揪卡</span> 说: 我还是不太明白你的方法，abacadaeacab你要怎么做呢？应该是4次吧？</q></div>4次是怎么算的"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/53/345353.jpg","floor":"#7-7","id":"1432624","time":"2019-4-4 00:20","userId":"a_researcher","userName":"揪卡","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: 4次是怎么算的</q></div>去掉d，去掉e，去掉bacaaacab，去掉a"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7-8","id":"1432627","time":"2019-4-4 00:24","userId":"windrises","userName":"windrises","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">揪卡</span> 说: 去掉d，去掉e，去掉bacaaacab，去掉a</q></div>那我可以反过来先加个bacaaacab，然后在其中分别插入dea，也是四次"},{"avatar":"//lain.bgm.tv/pic/user/m/000/31/78/317841.jpg","floor":"#7-9","id":"1432628","time":"2019-4-4 00:24","userId":"smileandyxu","userName":"smileandyxu","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: 1、a a a d a a a <br>2、a b a a d a a a <br>3、a b a c a d a a a <br>4、a b a c a d a e a a <br>5、a b a c a d a e a ...</q></div>不好意思刚弄错，算掉了中间的d<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"><br>但个人觉得还是很奇怪，比如<br>abacadaeafagafd<br>它有多种拆法，<br>按照daafaad, aaa, bcegf 一共7次(这回貌似没算错吧？)<br>但另一边aaaaaaa, dfgfd, bce一共5次，起手长度一样，而且应该不会比7更长的子序列了？"},{"avatar":"//lain.bgm.tv/pic/user/m/icon.jpg","floor":"#7-10","id":"1432631","time":"2019-4-4 00:34","userId":"455308","userName":"TargetLocked","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: 那不是我的意思</q></div>那么是说删除子序列后分割出的若干串互相独立？如果这样的话，贪心的正确性并没有保证，可以考虑abbxayzyx……"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/53/345353.jpg","floor":"#7-11","id":"1432632","time":"2019-4-4 00:35","userId":"a_researcher","userName":"揪卡","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: 那我可以反过来先加个bacaaacab，然后在其中分别插入dea，也是四次</q></div>你要怎么找插入的位置"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7-12","id":"1432633","time":"2019-4-4 00:36","userId":"windrises","userName":"windrises","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">smileandyxu</span> 说: 不好意思刚弄错，算掉了中间的d<br>但个人觉得还是很奇怪，比如<br>abacadaeafagafd<br>它有多种拆法，<br>按照daafaad, aaa, bcegf 一共7次(这回貌似没算错吧？)<br>但另一边aaaa...</q></div>我觉得你说的很有道理，虽然我没去验证你说的这个有没有比7更长的子序列，不过肯定会存在这种类似的问题<br>所以说贪心往往是有问题的<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"><br><br>我觉得如果遇到当前状态有多个长度一样的最长子序列的话，可以来个dfs搜索一下，虽然很暴力，不过我觉得平均情况下应该不会太差<br><br>不过这也只是猜想，很可能又会冒出别的问题"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7-13","id":"1432634","time":"2019-4-4 00:39","userId":"windrises","userName":"windrises","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">揪卡</span> 说: 你要怎么找插入的位置</q></div>在得到最长子序列的同时，也能得到其中每个数在原数组的位置，按原位置插入就行了"},{"avatar":"//lain.bgm.tv/pic/user/m/000/14/07/140749.jpg","floor":"#7-14","id":"1432640","time":"2019-4-4 00:48","userId":"black_tea2333","userName":"Black_tea","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: 我觉得你说的很有道理，虽然我没去验证你说的这个有没有比7更长的子序列，不过肯定会存在这种类似的问题<br>所以说贪心往往是有问题的<br><br>我觉得如果遇到当前状态有多个长度一样的最长子序列的话，可以来个dfs搜索...</q></div>上面提出的例子不太好，最长的不一定是最好的，考虑这个：<br><div class=\"codeHighlight\"><pre>(5(1 2 1 7 7 1 2 1)5 4 5 5)<br>最长为 (5 1 2 1 7 7 1 2 1 5) ，需要额外加入 4，5 5<br>但是如果改为 (5 5 4 5 5)，(1 2 1 7 7 1 2 1)，这就只需两次</pre></div>"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7-15","id":"1432645","time":"2019-4-4 00:53","userId":"windrises","userName":"windrises","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">Black_tea</span> 说: 上面提出的例子不太好，最长的不一定是最好的，考虑这个：<br>(5(1 2 1 7 7 1 2 1)5 4 5 5)<br>最长为 (5 1 2 1 7 7 1 2 1 5) ，需要额外加入 4，5 5<br>但是如果...</q></div>你这个例子也不太好 <img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"><br>其实只需要额外加入5 4 5 也是两次 <img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#7-16","id":"1432646","time":"2019-4-4 00:54","userId":"windrises","userName":"windrises","userSign":"","message":"我只是随便说说我yy的猜想，很可能是有问题的，你们不要老是回复我了<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">"},{"avatar":"//lain.bgm.tv/pic/user/m/000/14/07/140749.jpg","floor":"#7-17","id":"1432648","time":"2019-4-4 00:55","userId":"black_tea2333","userName":"Black_tea","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: 你这个例子也不太好 <br>其实只需要额外加入5 4 5 也是两次 </q></div><img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"><span style=\"font-size:10px; line-height:10px;\">这是最后一次回复</span>"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#8","id":"1432603","time":"2019-4-3 23:49","userId":"windrises","userName":"windrises","userSign":"(一个纠结的面瘫伪宅)","message":"举个栗子吧<br>4 5 5 4 1 2 3 4 5 5 4<br>正确方法应该是先用两次来去掉1 2 3 中的两个数，然后剩下的可以一次去掉，一共需要三次操作<br>而不是先去掉两个4 5 5 4，然后再分别去掉1 2 3，因为这样需要五次操作<br><br>-------------<br>我上面说的S在第一次去掉s之后就变成分段的多个数组了，之后再求最长子序列都是在每个小段里面求，插入时也是一样","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/31/05/310594.jpg","floor":"#8-1","id":"1432669","time":"2019-4-4 02:09","userId":"tmpfs","userName":"​","userSign":"","message":"你们是怎么定义子串的？<br><br>45541234554的最长回文子串是455414554或者455424554或者455434554。<br><br>删掉455414554，剩下23。继续找最长回文子串。<br><br>有什么问题？"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/53/345353.jpg","floor":"#8-2","id":"1432689","time":"2019-4-4 07:57","userId":"a_researcher","userName":"揪卡","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">​</span> 说: 你们是怎么定义子串的？<br><br>45541234554的最长回文子串是455414554或者455424554或者455434554。<br><br>删掉455414554，剩下23。继续找最长回文子串。<br><br>有什么问题...</q></div>子串和子序列不一样的，你说的是子序列"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/31/05/310594.jpg","floor":"#9","id":"1432673","time":"2019-4-4 02:38","userId":"tmpfs","userName":"​","userSign":"","message":"啊，还是你说的，同样长度不同划分剩下的串又有继续划分次数多少","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/27/39/273934.jpg","floor":"#10","id":"1432688","time":"2019-4-4 07:56","userId":"273934","userName":"本子战士","userSign":"(B站难民)","message":"楼主能更细致的描述自己的算法吗？比如写一下时间复杂度和dp的公式。要不然不是很好比较呀。","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/00/34/3490.jpg","floor":"#11","id":"1432788","time":"2019-4-4 14:06","userId":"lhb5883","userName":"lhb5883-污🐱王VIP⑩","userSign":"(媛娇系是检验大法的唯一标准)","message":"是不是玩祖玛崩溃了？<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"><br>穷举大法好","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/32/23/322380.jpg","floor":"#12","id":"1432804","time":"2019-4-4 15:18","userId":"322380","userName":"此间的少年x","userSign":"","message":"问了一个竞赛金牌大佬，他给了一个O(n^4)的解法：<br>f[i ][j]表示 消除区间[i,j]的代价，目标是f[1][n]，边界条件f[i ][i ] = 1<br>为求解f[i ][j],用下面两种来更新，初始f[i ][j] = 正无穷<br>1 找到x, y使得[i,i+x-1] 和 [j - y + 1, j]拼一起是一个回文串，用1+f[i+x][j-y]更新f[i ][j]，i <= x < y <=j<br>2.  用f[i ][x] + f[x+1][y] + f[y+1][j]更新f[i ][j],    i <= x < y <=j","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#12-1","id":"1433572","time":"2019-4-7 13:48","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"dijkstra"},{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#12-2","id":"1433579","time":"2019-4-7 14:12","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"有一个问题，abcdejjjjjfgfeiiiiidcba 这样的。<br>所以需要寻找多重存在，那样就是 O(n^3 * 2^n)"},{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#12-3","id":"1433588","time":"2019-4-7 14:26","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"哦，我想错了，那样可以 jjjjjfgf 之后产生，两处错误，1. 中 “用1+f[i+x][j-y]更新f[i ][j]” 应为 “用f[i+x][j-y]更新f[i ][j]”，2. 中不需要拆三段，拆两段即可。<br>因为保证内部一定有刚被删除的回文串，那么只需要最后删除的那个再多删前后两个就行。<br>而拆三段一定被拆两段覆盖到，参考 dijkstra 算法。<br>——<br>该想法已经从 #12 跑偏，转 #14。"},{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#12-4","id":"1433596","time":"2019-4-7 14:42","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">InQβ</span> 说: 哦，我想错了，那样可以 jjjjjfgf 之后产生，两处错误，1. 中 “用1+f[i+x][j-y]更新f[i ][j]” 应为 “用f[i+x][j-y]更新f[i ][j]”，2. 中不需要拆三...</q></div>想了一下可以做出一个 最优 n 最差 n^2 平均 n log n 的，依赖缓存实现 DP 而非发现实现的 DP。<br>采用 C 那样的非对称子界而非 Pascal 的对称子界（为了实现 0 长度边界）<br>(define f (memproc (lambda (i j)<br>  (cond<br>    [(= i j) 0]<br>    [(= (1+ i) j) 1]<br>    [(= (ref s i) (ref s j)) (f (1+ i) (- j 1))]<br>    [else (min (map (lambda (k) (+ (f i k) (f k j))) (range (1+ i) j)))]))))"},{"avatar":"//lain.bgm.tv/pic/user/m/000/29/76/297631.jpg","floor":"#12-5","id":"1433597","time":"2019-4-7 14:46","userId":"ydc123","userName":"ydc","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">InQβ</span> 说: 想了一下可以做出一个 最优 n 最差 n^2 平均 n^3 的，依赖缓存实现 DP 而非发现实现的 DP。<br>采用 C 那样的非对称子界而非 Pascal 的对称子界（为了实现 0 长度边界）<br>(def...</q></div>这个算法没法解决“最后一次消除是将之前被分割成多段的回文串给消掉”的情况吧。。举个简单的例子abeca，你的做法应该是先消b，再消c，然后消aea"},{"avatar":"//lain.bgm.tv/pic/user/m/000/29/76/297631.jpg","floor":"#12-6","id":"1433600","time":"2019-4-7 14:47","userId":"ydc123","userName":"ydc","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">InQβ</span> 说: 想了一下可以做出一个 最优 n 最差 n^2 平均 n^3 的，依赖缓存实现 DP 而非发现实现的 DP。<br>采用 C 那样的非对称子界而非 Pascal 的对称子界（为了实现 0 长度边界）<br>(def...</q></div>但是这种消除策略是没法只通过“找到x, y使得[i,i+x-1] 和 [j - y + 1, j]拼一起是一个回文串，用1+f[i+x][j-y]更新f[i ][j]”所考虑到的"},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#12-7","id":"1433607","time":"2019-4-7 15:07","userId":"windrises","userName":"windrises","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">ydc</span> 说: InQβ 说: 想了一下可以做出一个 最优 n 最差 n^2 平均 n^3 的，依赖缓存实现 DP 而非发现实现的 DP。<br>采用 C 那样的非对称子界而非 Pascal 的对称子界（为了实现 0 长度...</q></div>没有考虑到多段问题+1<br>楼主发帖的当晚就有人说过这个方法了，不过貌似很快就意识到有问题然后删了"},{"avatar":"//lain.bgm.tv/pic/user/m/000/29/76/297631.jpg","floor":"#12-8","id":"1433608","time":"2019-4-7 15:11","userId":"ydc123","userName":"ydc","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: ydc 说: InQβ 说: 想了一下可以做出一个 最优 n 最差 n^2 平均 n^3 的，依赖缓存实现 DP 而非发现实现的 DP。<br>采用 C 那样的非对称子界而非 Pascal 的对称子界（为了...</q></div>我第一反应也是这个方法<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">"},{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#12-9","id":"1433614","time":"2019-4-7 15:55","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">ydc</span> 说: InQβ 说: 想了一下可以做出一个 最优 n 最差 n^2 平均 n^3 的，依赖缓存实现 DP 而非发现实现的 DP。<br>采用 C 那样的非对称子界而非 Pascal 的对称子界（为了实现 0 长度...</q></div>根本不用解决这个问题，按 DP 做法<br>首先发现消除 b 需要 1 次（length == 1）<br>然后发现消除 e 需要 1 次（length == 1）<br>然后发现消除 be 需要 2 次（=f(\"b\")+f(\"e\")）<br>然后发现消除 c 需要 1 次（length == 1）<br>然后发现消除 bec 需要 3 次（=f(\"be\")+f(\"c\")）<br>然后发现消除 abeca 需要 3 次（=f(\"bec\")）<br><br>或者说，按照 breakdown 做法<br>f(\"abeca\")=f(\"bec\") （因为 'a'=='a'）<br>然后就很容易地一个个去掉就行。<br>根本没有多段问题。"},{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#12-10","id":"1433617","time":"2019-4-7 16:02","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">ydc</span> 说: InQβ 说: 想了一下可以做出一个 最优 n 最差 n^2 平均 n^3 的，依赖缓存实现 DP 而非发现实现的 DP。<br>采用 C 那样的非对称子界而非 Pascal 的对称子界（为了实现 0 长度...</q></div>在 <a href=\"https://gist.github.com/no1xsyzy/9f10ccc3f90388e93b3317027be5f44c\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">https://gist.github.com/no1xsyzy/9f10ccc3f90388e93b3317027be5f44c</a> 添加了样例 #12-5"},{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#12-11","id":"1433619","time":"2019-4-7 16:10","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">windrises</span> 说: ydc 说: InQβ 说: 想了一下可以做出一个 最优 n 最差 n^2 平均 n^3 的，依赖缓存实现 DP 而非发现实现的 DP。<br>采用 C 那样的非对称子界而非 Pascal 的对称子界（为了...</q></div>测试过没有问题 <a href=\"https://gist.github.com/no1xsyzy/9f10ccc3f90388e93b3317027be5f44c\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">https://gist.github.com/no1xsyzy/9f10ccc3f90388e93b3317027be5f44c</a><br>楼上的样例都加进去了。<br>我的想法已经从 #12 跑偏，请看 #14"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/29/76/297631.jpg","floor":"#13","id":"1433594","time":"2019-4-7 14:38","userId":"ydc123","userName":"ydc","userSign":"","message":"想不出多项式算法，只能想出指数级别的暴力。<br>dp<span style=\"font-style:italic\">[j]表示把串[i,j]给干掉的最少次数，我们考虑干掉[i,j]的最后一次操作，他肯定是取出[i,j]这段区间里的某些字符，这些字符按顺序拼起来形成一个回文串。当然这些字符不一定连续，所以你把他们给拿掉，就能把[i,j]分成若干段。<br>由于你刚才取走的数是最后一次操作取的，所以这些段在消掉时肯定彼此独立，就把这些段的花费加起来再加1来更新dp<span style=\"font-style:italic\">[j]即可</span></span>","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#14","id":"1433612","time":"2019-4-7 15:50","userId":"no1xsyzy","userName":"InQβ","userSign":"(僕と契約して魔法少女になってよ！)","message":"<a href=\"https://gist.github.com/no1xsyzy/9f10ccc3f90388e93b3317027be5f44c\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">https://gist.github.com/no1xsyzy/9f10ccc3f90388e93b3317027be5f44c</a><br><br>想了想，这个应该是最好的了。<br>别被 “回文” 骗了，我的代码里根本没有寻找回文串的过程，也没有判断回文串的过程，甚至到最后也不知道是否存在回文串。<br>只用到一个特性：任何一个回文串前后各加同一个字符还是一个回文串。<br>因为是 equal? 所以对 (listof any/c) 有效。<br><br>顺便把测试用例加上了。","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#14-1","id":"1433621","time":"2019-4-7 16:18","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"其实标准的是<a href=\"https://gist.github.com/no1xsyzy/9f10ccc3f90388e93b3317027be5f44c/4058f03f78e128c3b61b92ef617944919330c1dc\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">这个版本</a>。<br>解释如下：<br>if 长度 = 0，then 需要删除次数 = 0；<br>elseif 长度 = 1，then 需要删除次数 = 1 次；<br>elseif 长度 = 2，且两个字符相同，then 需要删除次数 = 1；<br>elseif 首尾两个字符相同，then 需要删除次数 = 去掉这首尾两个字符后的需要删除次数。<br>else 需要删除次数 = 分成两段分别求需要删除次数并相加，求其中的最小值。"},{"avatar":"//lain.bgm.tv/pic/user/m/000/28/57/285770.jpg","floor":"#14-2","id":"1433622","time":"2019-4-7 16:20","userId":"no1xsyzy","userName":"InQβ","userSign":"","message":"符合要求并且复杂度为 O(n^2)。如若不服请给反例。<br>改写成正常的 DP 不会花太多功夫的，记得优先求 j-i 比较小的。"},{"avatar":"//lain.bgm.tv/pic/user/m/000/29/76/297631.jpg","floor":"#14-3","id":"1433625","time":"2019-4-7 16:25","userId":"ydc123","userName":"ydc","userSign":"","message":"哦哦哦，我觉得您说的很对<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/34/68/346809.jpg","floor":"#15","id":"1433629","time":"2019-4-7 16:52","userId":"windrises","userName":"windrises","userSign":"(一个纠结的面瘫伪宅)","message":"自言自语，没有仔细思考瞎胡说的，请不要回复我<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"><br><br><div class=\"codeHighlight\"><pre>之所以我一开始就在7楼说不能直接来dp，状态会爆炸，是因为：<br>不能简单的用dp[i][j]来表示消除i~j子串所需要的次数<br>我觉得得用dp[i][j][s]表示处理完i~j子串最后剩余s时，所需要的次数 原因就不说了<br>然后问题在于枚举s不是多项式复杂度</pre></div>","sub":[]}]