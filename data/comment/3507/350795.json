[{"avatar":"//lain.bgm.tv/pic/user/m/000/05/02/50293.jpg","floor":"#2","id":"1446189","time":"2019-5-25 09:55","userId":"simon007","userName":"Simon Chan","userSign":"","message":"因为 <a href=\"https://moca-news.net/article/20131106/2013110616530a_/image009.html\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">https://moca-news.net/article/20 ... 530a_/image009.html</a> 在调用 image_load_body 之前有个 HTTP 请求，时间轴是这样的<br>网页加载 -> 发起 HTTP 请求 -> user script 劫持 image_load_body -> HTTP 请求完成 -> 调用被劫持的 image_load_body<br><br>而 <a href=\"https://moca-news.net/imgsearch/?mode=V&seq=21&w=%8D%B2%81X%96%D8%96%A2%97%88&artid=2013110616530a_\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">https://moca-news.net/imgsearch/ ... tid=2013110616530a_</a> 没有这个 HTTP 请求，时间轴就是<br>网页加载 -> 调用 image_load_body -> user script 劫持 image_load_body<br><br>如果把 run-at 改成 document-start 的话，只会被 large_image.js 里的定义覆盖<br><br>我实验了在 document-start 的时候 Object.define(window, 'image_load_body', { value: xxx, writable: false })，但是会导致 large_image.js 里的 function 定义报错，如果在 user script 里把 large_image.js 里报错导致没执行的代码手动执行一次的话或许会有效","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/00/10/1010.jpg","floor":"#2-1","id":"1446208","time":"2019-5-25 11:39","userId":"fireattack","userName":"烈之斩","userSign":"","message":"多谢，也就是说正常来说，无法做到在网页自带的脚本“加载”和“运行”之间插入user script？"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/09/57/95768.jpg","floor":"#3","id":"1446197","time":"2019-5-25 11:03","userId":"a_little","userName":"拿月亮自刎","userSign":"(情更怯)","message":"我的思路是这样的： 在 文档加载完成的时候注入脚本。这个脚本先把 会执行 image_load_body  script 标签 移除 DOM 树，然后  eval.   借鉴了一下 ls 的 Object.defineProperty 的思路。<br><br>另外我本来想 移除所以 body 里面的 script，然后 eval 执行的。但是有个问题没处理好。<br><br>PS： LZ 使用的方法的方向不一定对的。可能有更好的方法。<br><br><div class=\"codeHighlight\"><pre><br>// ==UserScript==<br>// @name         New Userscript<br>// @namespace    http://tampermonkey.net/<br>// @version      0.1<br>// @description  try to take over the world!<br>// @author       You<br>// @match        https://moca-news.net/imgsearch/*<br>// @grant        none<br>// @run-at document-end<br>// ==/UserScript==<br><br>(function() {<br>    'use strict';<br>const changeScriptExe = `<br>function image_load_body(art_id, img_id, _mode, _retry) {<br>    console.log('image_load_body replaced');<br>}<br>Object.defineProperty(window, 'image_load_body', { value: image_load_body, writable: false })<br>    var aa = Array.prototype.slice.call(document.body.getElementsByTagName('script'));<br>aa = []<br>    aa.forEach((elem,index) =>{<br>        elem.remove()<br>    });<br>var targetScript = document.querySelector('#resize-button').nextElementSibling;<br>targetScript.remove();<br>    setTimeout(()=> {<br><br>eval(targetScript.innerText);<br>console.log('1111111111');<br>       aa.forEach((elem,index) =>{<br>eval(elem.innerText);<br>        //document.body.appendChild(elem);<br>    });<br>    }, 1000);<br>`<br>addJS_Node(changeScriptExe);<br>//addJS_Node(image_load_body);<br><br>function addJS_Node(text, s_URL, funcToRun, runOnLoad) {<br><br>    var D = document;<br><br>    var scriptNode = D.createElement('script');<br><br>    if (runOnLoad) {<br><br>        scriptNode.addEventListener(\"load\", runOnLoad, false);<br><br>    }<br><br>    scriptNode.type = \"text/javascript\";<br><br>    if (text) scriptNode.textContent = text;<br><br>    if (s_URL) scriptNode.src = s_URL;<br><br>    if (funcToRun) scriptNode.textContent = '(' + funcToRun.toString() + ')()';<br><br>    var targ = D.getElementsByTagName('head')[0] || D.body || D.documentElement;<br><br><br>    targ.appendChild(scriptNode);<br><br>}<br><br><br><br><br>})();<br></pre></div>","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/00/10/1010.jpg","floor":"#3-1","id":"1446211","time":"2019-5-25 11:42","userId":"fireattack","userName":"烈之斩","userSign":"","message":"首先多谢<br><br>我试了你的脚本，虽然成功替换了image_load_body并执行了一次，但是原始的image_load_body也被执行了（否则图片应该加载不出来）。"}]}]