[{"avatar":"//lain.bgm.tv/pic/user/m/000/01/18/11896.jpg","floor":"#2","id":"1303183","time":"2018-1-3 13:42","userId":"11896","userName":"JarvieK","userSign":"","message":"<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">不明白给json object的field排序有什么意义<br><a href=\"https://stackoverflow.com/questions/3948206/json-order-mixed-up\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">https://stackoverflow.com/questions/3948206/json-order-mixed-up</a><br><br><span style=\"text-decoration: line-through;\">，非要排的话：<br><a href=\"https://gist.github.com/colingourlay/82506396503c05e2bb94#file-sortkeysby-js\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">https://gist.github.com/colingou ... #file-sortkeysby-js</a></span>","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/13/30/133075.jpg","floor":"#2-1","id":"1303188","time":"2018-1-3 13:52","userId":"liaune","userName":"君寻","userSign":"","message":"我是想统计一个数组<br>[str1,str2, ... ,str(n)]<br>里面每个str出现的次数，得到一个json<br>{str1:num1,str2:num2, ... ,str(n):num(n)}<br>但是发现这个结果不好排序"},{"avatar":"//lain.bgm.tv/pic/user/m/000/01/18/11896.jpg","floor":"#2-2","id":"1303190","time":"2018-1-3 13:57","userId":"11896","userName":"JarvieK","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">君寻</span> 说: 我是想统计一个数组<br>[str1,str2, ... ,str(n)]<br>里面每个str出现的次数，得到一个json<br>{str1:num1,str2:num2, ... ,str(n):num(n)}<br>但...</q></div>要不要转成<br>[{\"key\": \"str1\", \"count\": 1}, {...}]<br>这样，然后根据需求分别转一个出来（<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">"},{"avatar":"//lain.bgm.tv/pic/user/m/000/13/30/133075.jpg","floor":"#2-3","id":"1303194","time":"2018-1-3 14:08","userId":"liaune","userName":"君寻","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">JarvieK</span> 说: 要不要转成<br>[{\"key\": \"str1\", \"count\": 1}, {...}]<br>这样，然后根据需求分别转一个出来（</q></div>我现在就是这样做的<br>但是从[str1,str2, ... ,str(n)]直接得到 [{\"key\": \"str1\", \"count\": 1}, {...}] 的结构好像不太容易"},{"avatar":"//lain.bgm.tv/pic/user/m/000/01/18/11896.jpg","floor":"#2-4","id":"1303197","time":"2018-1-3 14:30","userId":"11896","userName":"JarvieK","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">君寻</span> 说: 我现在就是这样做的<br>但是从[str1,str2, ... ,str(n)]直接得到 [{\"key\": \"str1\", \"count\": 1}, {...}] 的结构好像不太容易</q></div>_.chain([\"str1\", \"str1\", \"str2\", \"str2\"])<br>.groupBy((elem) => { return elem; })<br>.mapValues((val) => { return val.length; })<br>.value()<br><img src=\"/img/smiles/tv/01.gif\" smileid=\"40\" alt=\"(bgm24)\">"},{"avatar":"//lain.bgm.tv/pic/user/m/000/01/18/11896.jpg","floor":"#2-5","id":"1303198","time":"2018-1-3 14:34","userId":"11896","userName":"JarvieK","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">JarvieK</span> 说: _.chain([\"str1\", \"str1\", \"str2\", \"str2\"])<br>.groupBy((elem) => { return elem; })<br>.mapValues((val) => {...</q></div>然后可以再加一个<br>.map((v, k) => { return { \"key\": k, \"count\": v }; })"},{"avatar":"//lain.bgm.tv/pic/user/m/000/07/61/76150.jpg","floor":"#2-6","id":"1303254","time":"2018-1-3 23:12","userId":"binota","userName":"' ","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">君寻</span> 说: 我是想统计一个数组<br>[str1,str2, ... ,str(n)]<br>里面每个str出现的次数，得到一个json<br>{str1:num1,str2:num2, ... ,str(n):num(n)}<br>但...</q></div>如果是統計頻率的話，用 reduce 有解<br><br><div class=\"codeHighlight\"><pre><br>const data = [1, 1, 2, 2, 4, 5, 5, 5, 5, 7, 9, 10];<br>data<br>  .reduce((c, i) => { c[i] |= 0; c[i]++; return c; }, {});<br></pre></div><br><br>至於 #1 的解我在 #10 寫了"},{"avatar":"//lain.bgm.tv/pic/user/m/000/00/10/1010.jpg","floor":"#2-7","id":"1303305","time":"2018-1-4 05:40","userId":"fireattack","userName":"烈之斩","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">JarvieK</span> 说: _.chain([\"str1\", \"str1\", \"str2\", \"str2\"])<br>.groupBy((elem) => { return elem; })<br>.mapValues((val) => {...</q></div>用arrow function就不要这么多无必要的大括号了嘛<br><br>_.chain([\"str1\", \"str1\", \"str2\", \"str2\"])<br>.groupBy(elem => elem)<br>.mapValues(val => val.length)<br>.map((v, k) => ({ \"key\": k, \"count\": v }))<br>.value()"},{"avatar":"//lain.bgm.tv/pic/user/m/000/01/18/11896.jpg","floor":"#2-8","id":"1303307","time":"2018-1-4 06:39","userId":"11896","userName":"JarvieK","userSign":"","message":"<div class=\"quote\"><q><span style=\"font-weight:bold;\">烈之斩</span> 说: 用arrow function就不要这么多无必要的大括号了嘛<br><br>_.chain([\"str1\", \"str1\", \"str2\", \"str2\"])<br>.groupBy(elem => elem)<br>.ma...</q></div><img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\">大佬说的对"}]},{"avatar":"//lain.bgm.tv/pic/user/m/000/09/39/93929.jpg","floor":"#3","id":"1303184","time":"2018-1-3 13:44","userId":"flagalac","userName":"Flagalac","userSign":"","message":"这个主要看语言吧，没有现成的自己写个也不麻烦","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/00/38/3833.jpg","floor":"#4","id":"1303195","time":"2018-1-3 14:22","userId":"3833","userName":"knife","userSign":"","message":"在绝大多数语言的实现里，map都是不保证顺序的","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/25/55/255501.jpg","floor":"#5","id":"1303199","time":"2018-1-3 15:14","userId":"kakinuma","userName":"事实是柿子 - ⭐️VIP3","userSign":"(xD)","message":"我碰到这个问题的时候是这么搞的<img src=\"/img/smiles/tv/15.gif\" smileid=\"54\" alt=\"(bgm38)\"><br>{keyLisy:[key1-n],valueList:[value1-n]}","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/08/95/89561.jpg","floor":"#6","id":"1303200","time":"2018-1-3 15:19","userId":"upsuper","userName":"upsuper","userSign":"","message":"JS里对象字典的顺序对于非数字字符串使用的是插入序，所以你要做的是弄成数组排好然后按顺序插入结果的对象里","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/02/41/24149.jpg","floor":"#7","id":"1303206","time":"2018-1-3 16:45","userId":"henix","userName":"henix","userSign":"","message":"这种任务用函数式编程的库来解决非常适合。比如用个人比较喜欢的 <a href=\"http://ramdajs.com/\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">ramdajs</a>：<br><br>// 用 js 统计词频<br>const words = [ \"hello\", \"world\", \"hello\", \"world2\" ];<br>// 1. 将数组转换为 object ，其中键为某个数组元素，值为该数组元素出现的次数<br>const wordCounts = R.map(R.length)(R.groupBy(R.identity, words)); // => {hello: 2, world: 1, world2: 1}<br>// 2. 按 value 倒序排序，value 越大的排在前面：<br>R.sortBy(kv => -kv[1])(R.toPairs(wordCounts)) // => [[\"hello\", 2], [\"world\", 1], [\"world2\", 1]]<br><br>排序结果只能是数组，因为 object 的 key 的遍历顺序是没法保证的。<br><br>其实也就3行了啦...<img src=\"/img/smiles/tv/01.gif\" smileid=\"40\" alt=\"(bgm24)\">","sub":[{"avatar":"//lain.bgm.tv/pic/user/m/000/13/30/133075.jpg","floor":"#7-1","id":"1303242","time":"2018-1-3 22:18","userId":"liaune","userName":"君寻","userSign":"","message":"我还是觉得可以不用外部脚本就先不用..."}]},{"avatar":"//lain.bgm.tv/pic/user/m/icon.jpg","floor":"#8","id":"1303240","time":"2018-1-3 22:01","userId":"labmennosos","userName":"LabmenNoSOS","userSign":"","message":"<div class=\"codeHighlight\"><pre><br>var data = {\"A\":4, \"P\":8, \"T\":6, \"X\":9};<br>var sortedKeyValuePairs = Object.keys(data)<br>    .map(function(key){return {\"key\":key, \"value\":data[key]};})<br>    .sort(function(x, y){return x.value - y.value;});<br></pre></div>","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/00/34/3490.jpg","floor":"#9","id":"1303243","time":"2018-1-3 22:25","userId":"lhb5883","userName":"lhb5883-污🐱王VIP⑩","userSign":"(媛娇系是检验大法的唯一标准)","message":"你用的什么语言？","sub":[]},{"avatar":"//lain.bgm.tv/pic/user/m/000/07/61/76150.jpg","floor":"#10","id":"1303247","time":"2018-1-3 22:43","userId":"binota","userName":"' ","userSign":"","message":"你已經想到可以轉成 Array 再來排列了嘛：<br><div class=\"codeHighlight\"><pre><br>const origin = { key5: \"value5\", key1: \"value1\", key4: \"value4\", key2: \"value2\", key3: \"value3\" };<br>Object.assign(<br>  ...Object<br>    .entries(origin)<br>    .sort((a, b) => a[0] > b[0] ? 1 : -1)<br>    .map(i => ({[i[0]]: i[1]}))<br>);<br></pre></div><br><br>先用 Object.entries() 轉成 Array（[key, value]），sort 後 map 轉成 Object，用 Object.assign 搭配 Spread Operator 來達成合併數組內各個 Objects。<br><br>參考資料：<br><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">Object.entries()</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">Spread Operator</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"nofollow external noopener\" class=\"l\">Object.assign()</a>","sub":[]}]